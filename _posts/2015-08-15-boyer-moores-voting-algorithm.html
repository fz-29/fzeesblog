---
layout: post
title: Boyer-Moore's Voting Algorithm
date: 2015-08-15 18:18:45.000000000 +05:30
type: post
published: true
status: publish
categories:
- Algorithms
- Spoj
tags:
- BOYER
- MAJORITY
- MOORE
- SPOJ MAJOR
- VOTING
- VOTING ALGO
- VOTING ALGORITHM
meta:
  _edit_last: '82754425'
  geo_public: '0'
  _publicize_job_id: '13761718915'
author:
  login: feroz29
  email: f29ahmad@gmail.com
  display_name: feroz29
  first_name: ''
  last_name: ''
---
<p>Moore's Voting algorithm has 2 parts -</p>
<p>1. First part of running Moore's Voting algorithm only gives you A candidate which occurs "most" of the time in the given array.<br />
2. In the second part, we need to iterate over the array once again to determine if this candidate occurs maximum number of times (i.e. greater than size/2 times).</p>
<p>First iteration is to find the candidate &amp; second iteration is to check if this element occurs majority of times in the given array.</p>
<p>So time complexity is: O(n) + O(n) ≈ O(n)</p>
<p>---------------------------------------------------------</p>
<p><em><strong>1.Finding a Candidate:</strong></em><br />
The algorithm for first phase that works in O(n) is known as Moore’s Voting Algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element.</p>
<p>findCandidate(a[], size)<br />
1. Initialize index and count of majority element<br />
maj_index = 0, count = 1<br />
2. Loop for i = 1 to size – 1<br />
(a)If count == 0<br />
maj_index = i;<br />
count = 1</p>
<p>(b)If a[maj_index] == a[i]<br />
count++<br />
(c)Else<br />
count--;</p>
<p>3. Return a[maj_index]</p>
<p>--<br />
<em><strong>2. Check if the element obtained in step 1 is majority</strong></em></p>
<p>printMajority (a[], size)<br />
1. Find the candidate for majority<br />
2. If candidate is majority. i.e., appears more than n/2 times.<br />
Print the candidate<br />
3. Else<br />
Print "NONE"</p>
